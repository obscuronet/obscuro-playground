package crypto

import (
	"crypto/ecdsa"
	"fmt"

	gethcommon "github.com/ethereum/go-ethereum/common"
	gethcrypto "github.com/ethereum/go-ethereum/crypto"
	"github.com/ten-protocol/go-ten/go/common"
)

func GenerateEnclaveKey() (*EnclaveKey, error) {
	privKey, err := gethcrypto.GenerateKey()
	if err != nil {
		return nil, fmt.Errorf("could not generate enclave key. Cause: %w", err)
	}
	return NewEnclaveKey(privKey), nil
}

func NewEnclaveKey(privKey *ecdsa.PrivateKey) *EnclaveKey {
	pubKey := gethcrypto.CompressPubkey(&privKey.PublicKey)
	enclaveID := common.EnclaveID(pubKey[gethcommon.HashLength-gethcommon.AddressLength:])
	return &EnclaveKey{
		privateKey:     privKey,
		publicKeyBytes: pubKey,
		enclaveID:      enclaveID,
	}
}

// EnclaveKey - encapsulates behaviour for the enclave's private key (used to identify the enclave and sign messages)
type EnclaveKey struct {
	privateKey     *ecdsa.PrivateKey // generated by the enclave at startup, used to sign messages
	enclaveID      common.EnclaveID  // the enclave's ID, derived from the public key
	publicKeyBytes []byte
}

func (k *EnclaveKey) PrivateKey() *ecdsa.PrivateKey {
	return k.privateKey
}

func (k *EnclaveKey) PublicKey() *ecdsa.PublicKey {
	return &k.privateKey.PublicKey
}

func (k *EnclaveKey) EnclaveID() common.EnclaveID {
	return k.enclaveID
}

func (k *EnclaveKey) PublicKeyBytes() []byte {
	return k.publicKeyBytes
}
