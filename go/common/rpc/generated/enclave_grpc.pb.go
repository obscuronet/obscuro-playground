// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.2
// source: enclave.proto

package generated

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	EnclaveProto_Status_FullMethodName                 = "/generated.EnclaveProto/Status"
	EnclaveProto_Attestation_FullMethodName            = "/generated.EnclaveProto/Attestation"
	EnclaveProto_GenerateSecret_FullMethodName         = "/generated.EnclaveProto/GenerateSecret"
	EnclaveProto_InitEnclave_FullMethodName            = "/generated.EnclaveProto/InitEnclave"
	EnclaveProto_EnclaveID_FullMethodName              = "/generated.EnclaveProto/EnclaveID"
	EnclaveProto_SubmitL1Block_FullMethodName          = "/generated.EnclaveProto/SubmitL1Block"
	EnclaveProto_SubmitTx_FullMethodName               = "/generated.EnclaveProto/SubmitTx"
	EnclaveProto_SubmitBatch_FullMethodName            = "/generated.EnclaveProto/SubmitBatch"
	EnclaveProto_ObsCall_FullMethodName                = "/generated.EnclaveProto/ObsCall"
	EnclaveProto_GetTransactionCount_FullMethodName    = "/generated.EnclaveProto/GetTransactionCount"
	EnclaveProto_Stop_FullMethodName                   = "/generated.EnclaveProto/Stop"
	EnclaveProto_GetTransaction_FullMethodName         = "/generated.EnclaveProto/GetTransaction"
	EnclaveProto_GetTransactionReceipt_FullMethodName  = "/generated.EnclaveProto/GetTransactionReceipt"
	EnclaveProto_GetBalance_FullMethodName             = "/generated.EnclaveProto/GetBalance"
	EnclaveProto_GetCode_FullMethodName                = "/generated.EnclaveProto/GetCode"
	EnclaveProto_GetStorageSlot_FullMethodName         = "/generated.EnclaveProto/GetStorageSlot"
	EnclaveProto_Subscribe_FullMethodName              = "/generated.EnclaveProto/Subscribe"
	EnclaveProto_Unsubscribe_FullMethodName            = "/generated.EnclaveProto/Unsubscribe"
	EnclaveProto_EstimateGas_FullMethodName            = "/generated.EnclaveProto/EstimateGas"
	EnclaveProto_GetLogs_FullMethodName                = "/generated.EnclaveProto/GetLogs"
	EnclaveProto_HealthCheck_FullMethodName            = "/generated.EnclaveProto/HealthCheck"
	EnclaveProto_GetBatch_FullMethodName               = "/generated.EnclaveProto/GetBatch"
	EnclaveProto_GetBatchBySeqNo_FullMethodName        = "/generated.EnclaveProto/GetBatchBySeqNo"
	EnclaveProto_GetRollupData_FullMethodName          = "/generated.EnclaveProto/GetRollupData"
	EnclaveProto_CreateBatch_FullMethodName            = "/generated.EnclaveProto/CreateBatch"
	EnclaveProto_CreateRollup_FullMethodName           = "/generated.EnclaveProto/CreateRollup"
	EnclaveProto_ExportCrossChainData_FullMethodName   = "/generated.EnclaveProto/ExportCrossChainData"
	EnclaveProto_DebugTraceTransaction_FullMethodName  = "/generated.EnclaveProto/DebugTraceTransaction"
	EnclaveProto_StreamL2Updates_FullMethodName        = "/generated.EnclaveProto/StreamL2Updates"
	EnclaveProto_DebugEventLogRelevancy_FullMethodName = "/generated.EnclaveProto/DebugEventLogRelevancy"
	EnclaveProto_GetTotalContractCount_FullMethodName  = "/generated.EnclaveProto/GetTotalContractCount"
	EnclaveProto_GetReceiptsByAddress_FullMethodName   = "/generated.EnclaveProto/GetReceiptsByAddress"
	EnclaveProto_EnclavePublicConfig_FullMethodName    = "/generated.EnclaveProto/EnclavePublicConfig"
)

// EnclaveProtoClient is the client API for EnclaveProto service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// todo (low priority) - remove these comments which duplicate those in common/enclave.go.
type EnclaveProtoClient interface {
	// Status is used to check whether the server is ready for requests.
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	// Attestation - Produces an attestation report which will be used to request the shared secret from another enclave.
	Attestation(ctx context.Context, in *AttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error)
	// GenerateSecret - the genesis enclave is responsible with generating the secret entropy
	GenerateSecret(ctx context.Context, in *GenerateSecretRequest, opts ...grpc.CallOption) (*GenerateSecretResponse, error)
	// Init - initialise an enclave with a seed received by another enclave
	InitEnclave(ctx context.Context, in *InitEnclaveRequest, opts ...grpc.CallOption) (*InitEnclaveResponse, error)
	// EnclaveID - request the EnclaveID from the enclave
	EnclaveID(ctx context.Context, in *EnclaveIDRequest, opts ...grpc.CallOption) (*EnclaveIDResponse, error)
	// SubmitL1Block - Used for the host to submit blocks to the enclave, these may be:
	//
	//	a. historic block - if the enclave is behind and in the process of catching up with the L1 state
	//	b. the latest block published by the L1, to which the enclave should respond with a rollup
	//
	// It is the responsibility of the host to gossip the returned rollup
	// For good functioning the caller should always submit blocks ordered by height
	// submitting a block before receiving ancestors of it, will result in it being ignored
	SubmitL1Block(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error)
	// SubmitTx - user transactions
	SubmitTx(ctx context.Context, in *SubmitTxRequest, opts ...grpc.CallOption) (*SubmitTxResponse, error)
	// SubmitBatch submits a batch received from the sequencer for processing.
	SubmitBatch(ctx context.Context, in *SubmitBatchRequest, opts ...grpc.CallOption) (*SubmitBatchResponse, error)
	// ObsCall - returns the result of executing the smart contract as a user, encrypted with the
	// viewing key corresponding to the `from` field
	ObsCall(ctx context.Context, in *ObsCallRequest, opts ...grpc.CallOption) (*ObsCallResponse, error)
	// GetTransactionCount - returns the nonce of the wallet with the given address.
	GetTransactionCount(ctx context.Context, in *GetTransactionCountRequest, opts ...grpc.CallOption) (*GetTransactionCountResponse, error)
	// Stop gracefully stops the enclave
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	// GetTransaction returns a transaction given its Signed Hash, returns nil, false when Transaction is unknown
	GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
	// GetTransaction returns a transaction receipt given the transaction's signed hash, encrypted with the viewing key
	// corresponding to the original transaction submitter
	GetTransactionReceipt(ctx context.Context, in *GetTransactionReceiptRequest, opts ...grpc.CallOption) (*GetTransactionReceiptResponse, error)
	// GetBalance returns the address's balance on the Obscuro network, encrypted with the viewing key corresponding to
	// the address
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error)
	// GetCode returns the code stored at the given address in the state for the given rollup height or rollup hash
	GetCode(ctx context.Context, in *GetCodeRequest, opts ...grpc.CallOption) (*GetCodeResponse, error)
	GetStorageSlot(ctx context.Context, in *GetStorageSlotRequest, opts ...grpc.CallOption) (*GetStorageSlotResponse, error)
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	// EstimateGas returns the estimation of gas used for the given transactions
	EstimateGas(ctx context.Context, in *EstimateGasRequest, opts ...grpc.CallOption) (*EstimateGasResponse, error)
	GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (*GetLogsResponse, error)
	// HealthCheck returns the health status of enclave + db
	HealthCheck(ctx context.Context, in *EmptyArgs, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// GetBatch returns the encrypted batch based on a hash
	GetBatch(ctx context.Context, in *GetBatchRequest, opts ...grpc.CallOption) (*GetBatchResponse, error)
	// GetBatch returns the encrypted batch based on a hash
	GetBatchBySeqNo(ctx context.Context, in *GetBatchBySeqNoRequest, opts ...grpc.CallOption) (*GetBatchResponse, error)
	// GetRollupData returns the first batch sequence number in the rollup and the timestamp
	GetRollupData(ctx context.Context, in *GetRollupDataRequest, opts ...grpc.CallOption) (*GetRollupDataResponse, error)
	CreateBatch(ctx context.Context, in *CreateBatchRequest, opts ...grpc.CallOption) (*CreateBatchResponse, error)
	CreateRollup(ctx context.Context, in *CreateRollupRequest, opts ...grpc.CallOption) (*CreateRollupResponse, error)
	ExportCrossChainData(ctx context.Context, in *ExportCrossChainDataRequest, opts ...grpc.CallOption) (*ExportCrossChainDataResponse, error)
	DebugTraceTransaction(ctx context.Context, in *DebugTraceTransactionRequest, opts ...grpc.CallOption) (*DebugTraceTransactionResponse, error)
	StreamL2Updates(ctx context.Context, in *StreamL2UpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[EncodedUpdateResponse], error)
	DebugEventLogRelevancy(ctx context.Context, in *DebugEventLogRelevancyRequest, opts ...grpc.CallOption) (*DebugEventLogRelevancyResponse, error)
	GetTotalContractCount(ctx context.Context, in *GetTotalContractCountRequest, opts ...grpc.CallOption) (*GetTotalContractCountResponse, error)
	GetReceiptsByAddress(ctx context.Context, in *GetReceiptsByAddressRequest, opts ...grpc.CallOption) (*GetReceiptsByAddressResponse, error)
	// EnclavePublicConfig returns public network data that is known to the enclave but may not be known to the host
	EnclavePublicConfig(ctx context.Context, in *EnclavePublicConfigRequest, opts ...grpc.CallOption) (*EnclavePublicConfigResponse, error)
}

type enclaveProtoClient struct {
	cc grpc.ClientConnInterface
}

func NewEnclaveProtoClient(cc grpc.ClientConnInterface) EnclaveProtoClient {
	return &enclaveProtoClient{cc}
}

func (c *enclaveProtoClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Attestation(ctx context.Context, in *AttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AttestationResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_Attestation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GenerateSecret(ctx context.Context, in *GenerateSecretRequest, opts ...grpc.CallOption) (*GenerateSecretResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateSecretResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GenerateSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) InitEnclave(ctx context.Context, in *InitEnclaveRequest, opts ...grpc.CallOption) (*InitEnclaveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitEnclaveResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_InitEnclave_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) EnclaveID(ctx context.Context, in *EnclaveIDRequest, opts ...grpc.CallOption) (*EnclaveIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveIDResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_EnclaveID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) SubmitL1Block(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitBlockResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_SubmitL1Block_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) SubmitTx(ctx context.Context, in *SubmitTxRequest, opts ...grpc.CallOption) (*SubmitTxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitTxResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_SubmitTx_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) SubmitBatch(ctx context.Context, in *SubmitBatchRequest, opts ...grpc.CallOption) (*SubmitBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitBatchResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_SubmitBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) ObsCall(ctx context.Context, in *ObsCallRequest, opts ...grpc.CallOption) (*ObsCallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ObsCallResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_ObsCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetTransactionCount(ctx context.Context, in *GetTransactionCountRequest, opts ...grpc.CallOption) (*GetTransactionCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTransactionCountResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetTransactionCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_Stop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTransactionResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetTransactionReceipt(ctx context.Context, in *GetTransactionReceiptRequest, opts ...grpc.CallOption) (*GetTransactionReceiptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTransactionReceiptResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetTransactionReceipt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBalanceResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetCode(ctx context.Context, in *GetCodeRequest, opts ...grpc.CallOption) (*GetCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCodeResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetStorageSlot(ctx context.Context, in *GetStorageSlotRequest, opts ...grpc.CallOption) (*GetStorageSlotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStorageSlotResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetStorageSlot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubscribeResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_Subscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_Unsubscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) EstimateGas(ctx context.Context, in *EstimateGasRequest, opts ...grpc.CallOption) (*EstimateGasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EstimateGasResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_EstimateGas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (*GetLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLogsResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) HealthCheck(ctx context.Context, in *EmptyArgs, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetBatch(ctx context.Context, in *GetBatchRequest, opts ...grpc.CallOption) (*GetBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBatchResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetBatchBySeqNo(ctx context.Context, in *GetBatchBySeqNoRequest, opts ...grpc.CallOption) (*GetBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBatchResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetBatchBySeqNo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetRollupData(ctx context.Context, in *GetRollupDataRequest, opts ...grpc.CallOption) (*GetRollupDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRollupDataResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetRollupData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) CreateBatch(ctx context.Context, in *CreateBatchRequest, opts ...grpc.CallOption) (*CreateBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBatchResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_CreateBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) CreateRollup(ctx context.Context, in *CreateRollupRequest, opts ...grpc.CallOption) (*CreateRollupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateRollupResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_CreateRollup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) ExportCrossChainData(ctx context.Context, in *ExportCrossChainDataRequest, opts ...grpc.CallOption) (*ExportCrossChainDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportCrossChainDataResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_ExportCrossChainData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) DebugTraceTransaction(ctx context.Context, in *DebugTraceTransactionRequest, opts ...grpc.CallOption) (*DebugTraceTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DebugTraceTransactionResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_DebugTraceTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) StreamL2Updates(ctx context.Context, in *StreamL2UpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[EncodedUpdateResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EnclaveProto_ServiceDesc.Streams[0], EnclaveProto_StreamL2Updates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamL2UpdatesRequest, EncodedUpdateResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EnclaveProto_StreamL2UpdatesClient = grpc.ServerStreamingClient[EncodedUpdateResponse]

func (c *enclaveProtoClient) DebugEventLogRelevancy(ctx context.Context, in *DebugEventLogRelevancyRequest, opts ...grpc.CallOption) (*DebugEventLogRelevancyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DebugEventLogRelevancyResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_DebugEventLogRelevancy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetTotalContractCount(ctx context.Context, in *GetTotalContractCountRequest, opts ...grpc.CallOption) (*GetTotalContractCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTotalContractCountResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetTotalContractCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetReceiptsByAddress(ctx context.Context, in *GetReceiptsByAddressRequest, opts ...grpc.CallOption) (*GetReceiptsByAddressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReceiptsByAddressResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetReceiptsByAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) EnclavePublicConfig(ctx context.Context, in *EnclavePublicConfigRequest, opts ...grpc.CallOption) (*EnclavePublicConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclavePublicConfigResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_EnclavePublicConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnclaveProtoServer is the server API for EnclaveProto service.
// All implementations must embed UnimplementedEnclaveProtoServer
// for forward compatibility.
//
// todo (low priority) - remove these comments which duplicate those in common/enclave.go.
type EnclaveProtoServer interface {
	// Status is used to check whether the server is ready for requests.
	Status(context.Context, *StatusRequest) (*StatusResponse, error)
	// Attestation - Produces an attestation report which will be used to request the shared secret from another enclave.
	Attestation(context.Context, *AttestationRequest) (*AttestationResponse, error)
	// GenerateSecret - the genesis enclave is responsible with generating the secret entropy
	GenerateSecret(context.Context, *GenerateSecretRequest) (*GenerateSecretResponse, error)
	// Init - initialise an enclave with a seed received by another enclave
	InitEnclave(context.Context, *InitEnclaveRequest) (*InitEnclaveResponse, error)
	// EnclaveID - request the EnclaveID from the enclave
	EnclaveID(context.Context, *EnclaveIDRequest) (*EnclaveIDResponse, error)
	// SubmitL1Block - Used for the host to submit blocks to the enclave, these may be:
	//
	//	a. historic block - if the enclave is behind and in the process of catching up with the L1 state
	//	b. the latest block published by the L1, to which the enclave should respond with a rollup
	//
	// It is the responsibility of the host to gossip the returned rollup
	// For good functioning the caller should always submit blocks ordered by height
	// submitting a block before receiving ancestors of it, will result in it being ignored
	SubmitL1Block(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error)
	// SubmitTx - user transactions
	SubmitTx(context.Context, *SubmitTxRequest) (*SubmitTxResponse, error)
	// SubmitBatch submits a batch received from the sequencer for processing.
	SubmitBatch(context.Context, *SubmitBatchRequest) (*SubmitBatchResponse, error)
	// ObsCall - returns the result of executing the smart contract as a user, encrypted with the
	// viewing key corresponding to the `from` field
	ObsCall(context.Context, *ObsCallRequest) (*ObsCallResponse, error)
	// GetTransactionCount - returns the nonce of the wallet with the given address.
	GetTransactionCount(context.Context, *GetTransactionCountRequest) (*GetTransactionCountResponse, error)
	// Stop gracefully stops the enclave
	Stop(context.Context, *StopRequest) (*StopResponse, error)
	// GetTransaction returns a transaction given its Signed Hash, returns nil, false when Transaction is unknown
	GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error)
	// GetTransaction returns a transaction receipt given the transaction's signed hash, encrypted with the viewing key
	// corresponding to the original transaction submitter
	GetTransactionReceipt(context.Context, *GetTransactionReceiptRequest) (*GetTransactionReceiptResponse, error)
	// GetBalance returns the address's balance on the Obscuro network, encrypted with the viewing key corresponding to
	// the address
	GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error)
	// GetCode returns the code stored at the given address in the state for the given rollup height or rollup hash
	GetCode(context.Context, *GetCodeRequest) (*GetCodeResponse, error)
	GetStorageSlot(context.Context, *GetStorageSlotRequest) (*GetStorageSlotResponse, error)
	Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	// EstimateGas returns the estimation of gas used for the given transactions
	EstimateGas(context.Context, *EstimateGasRequest) (*EstimateGasResponse, error)
	GetLogs(context.Context, *GetLogsRequest) (*GetLogsResponse, error)
	// HealthCheck returns the health status of enclave + db
	HealthCheck(context.Context, *EmptyArgs) (*HealthCheckResponse, error)
	// GetBatch returns the encrypted batch based on a hash
	GetBatch(context.Context, *GetBatchRequest) (*GetBatchResponse, error)
	// GetBatch returns the encrypted batch based on a hash
	GetBatchBySeqNo(context.Context, *GetBatchBySeqNoRequest) (*GetBatchResponse, error)
	// GetRollupData returns the first batch sequence number in the rollup and the timestamp
	GetRollupData(context.Context, *GetRollupDataRequest) (*GetRollupDataResponse, error)
	CreateBatch(context.Context, *CreateBatchRequest) (*CreateBatchResponse, error)
	CreateRollup(context.Context, *CreateRollupRequest) (*CreateRollupResponse, error)
	ExportCrossChainData(context.Context, *ExportCrossChainDataRequest) (*ExportCrossChainDataResponse, error)
	DebugTraceTransaction(context.Context, *DebugTraceTransactionRequest) (*DebugTraceTransactionResponse, error)
	StreamL2Updates(*StreamL2UpdatesRequest, grpc.ServerStreamingServer[EncodedUpdateResponse]) error
	DebugEventLogRelevancy(context.Context, *DebugEventLogRelevancyRequest) (*DebugEventLogRelevancyResponse, error)
	GetTotalContractCount(context.Context, *GetTotalContractCountRequest) (*GetTotalContractCountResponse, error)
	GetReceiptsByAddress(context.Context, *GetReceiptsByAddressRequest) (*GetReceiptsByAddressResponse, error)
	// EnclavePublicConfig returns public network data that is known to the enclave but may not be known to the host
	EnclavePublicConfig(context.Context, *EnclavePublicConfigRequest) (*EnclavePublicConfigResponse, error)
	mustEmbedUnimplementedEnclaveProtoServer()
}

// UnimplementedEnclaveProtoServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEnclaveProtoServer struct{}

func (UnimplementedEnclaveProtoServer) Status(context.Context, *StatusRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedEnclaveProtoServer) Attestation(context.Context, *AttestationRequest) (*AttestationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attestation not implemented")
}
func (UnimplementedEnclaveProtoServer) GenerateSecret(context.Context, *GenerateSecretRequest) (*GenerateSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateSecret not implemented")
}
func (UnimplementedEnclaveProtoServer) InitEnclave(context.Context, *InitEnclaveRequest) (*InitEnclaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitEnclave not implemented")
}
func (UnimplementedEnclaveProtoServer) EnclaveID(context.Context, *EnclaveIDRequest) (*EnclaveIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnclaveID not implemented")
}
func (UnimplementedEnclaveProtoServer) SubmitL1Block(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitL1Block not implemented")
}
func (UnimplementedEnclaveProtoServer) SubmitTx(context.Context, *SubmitTxRequest) (*SubmitTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTx not implemented")
}
func (UnimplementedEnclaveProtoServer) SubmitBatch(context.Context, *SubmitBatchRequest) (*SubmitBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBatch not implemented")
}
func (UnimplementedEnclaveProtoServer) ObsCall(context.Context, *ObsCallRequest) (*ObsCallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ObsCall not implemented")
}
func (UnimplementedEnclaveProtoServer) GetTransactionCount(context.Context, *GetTransactionCountRequest) (*GetTransactionCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionCount not implemented")
}
func (UnimplementedEnclaveProtoServer) Stop(context.Context, *StopRequest) (*StopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedEnclaveProtoServer) GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}
func (UnimplementedEnclaveProtoServer) GetTransactionReceipt(context.Context, *GetTransactionReceiptRequest) (*GetTransactionReceiptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionReceipt not implemented")
}
func (UnimplementedEnclaveProtoServer) GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedEnclaveProtoServer) GetCode(context.Context, *GetCodeRequest) (*GetCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCode not implemented")
}
func (UnimplementedEnclaveProtoServer) GetStorageSlot(context.Context, *GetStorageSlotRequest) (*GetStorageSlotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStorageSlot not implemented")
}
func (UnimplementedEnclaveProtoServer) Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedEnclaveProtoServer) Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedEnclaveProtoServer) EstimateGas(context.Context, *EstimateGasRequest) (*EstimateGasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateGas not implemented")
}
func (UnimplementedEnclaveProtoServer) GetLogs(context.Context, *GetLogsRequest) (*GetLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogs not implemented")
}
func (UnimplementedEnclaveProtoServer) HealthCheck(context.Context, *EmptyArgs) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedEnclaveProtoServer) GetBatch(context.Context, *GetBatchRequest) (*GetBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBatch not implemented")
}
func (UnimplementedEnclaveProtoServer) GetBatchBySeqNo(context.Context, *GetBatchBySeqNoRequest) (*GetBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBatchBySeqNo not implemented")
}
func (UnimplementedEnclaveProtoServer) GetRollupData(context.Context, *GetRollupDataRequest) (*GetRollupDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRollupData not implemented")
}
func (UnimplementedEnclaveProtoServer) CreateBatch(context.Context, *CreateBatchRequest) (*CreateBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBatch not implemented")
}
func (UnimplementedEnclaveProtoServer) CreateRollup(context.Context, *CreateRollupRequest) (*CreateRollupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRollup not implemented")
}
func (UnimplementedEnclaveProtoServer) ExportCrossChainData(context.Context, *ExportCrossChainDataRequest) (*ExportCrossChainDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportCrossChainData not implemented")
}
func (UnimplementedEnclaveProtoServer) DebugTraceTransaction(context.Context, *DebugTraceTransactionRequest) (*DebugTraceTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DebugTraceTransaction not implemented")
}
func (UnimplementedEnclaveProtoServer) StreamL2Updates(*StreamL2UpdatesRequest, grpc.ServerStreamingServer[EncodedUpdateResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamL2Updates not implemented")
}
func (UnimplementedEnclaveProtoServer) DebugEventLogRelevancy(context.Context, *DebugEventLogRelevancyRequest) (*DebugEventLogRelevancyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DebugEventLogRelevancy not implemented")
}
func (UnimplementedEnclaveProtoServer) GetTotalContractCount(context.Context, *GetTotalContractCountRequest) (*GetTotalContractCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTotalContractCount not implemented")
}
func (UnimplementedEnclaveProtoServer) GetReceiptsByAddress(context.Context, *GetReceiptsByAddressRequest) (*GetReceiptsByAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReceiptsByAddress not implemented")
}
func (UnimplementedEnclaveProtoServer) EnclavePublicConfig(context.Context, *EnclavePublicConfigRequest) (*EnclavePublicConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnclavePublicConfig not implemented")
}
func (UnimplementedEnclaveProtoServer) mustEmbedUnimplementedEnclaveProtoServer() {}
func (UnimplementedEnclaveProtoServer) testEmbeddedByValue()                      {}

// UnsafeEnclaveProtoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnclaveProtoServer will
// result in compilation errors.
type UnsafeEnclaveProtoServer interface {
	mustEmbedUnimplementedEnclaveProtoServer()
}

func RegisterEnclaveProtoServer(s grpc.ServiceRegistrar, srv EnclaveProtoServer) {
	// If the following call pancis, it indicates UnimplementedEnclaveProtoServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EnclaveProto_ServiceDesc, srv)
}

func _EnclaveProto_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Attestation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Attestation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_Attestation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Attestation(ctx, req.(*AttestationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GenerateSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GenerateSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GenerateSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GenerateSecret(ctx, req.(*GenerateSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_InitEnclave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitEnclaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).InitEnclave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_InitEnclave_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).InitEnclave(ctx, req.(*InitEnclaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_EnclaveID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnclaveIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).EnclaveID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_EnclaveID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).EnclaveID(ctx, req.(*EnclaveIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_SubmitL1Block_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).SubmitL1Block(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_SubmitL1Block_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).SubmitL1Block(ctx, req.(*SubmitBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_SubmitTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).SubmitTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_SubmitTx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).SubmitTx(ctx, req.(*SubmitTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_SubmitBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).SubmitBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_SubmitBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).SubmitBatch(ctx, req.(*SubmitBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_ObsCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObsCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).ObsCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_ObsCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).ObsCall(ctx, req.(*ObsCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetTransactionCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetTransactionCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetTransactionCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetTransactionCount(ctx, req.(*GetTransactionCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_Stop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetTransaction(ctx, req.(*GetTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetTransactionReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionReceiptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetTransactionReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetTransactionReceipt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetTransactionReceipt(ctx, req.(*GetTransactionReceiptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetCode(ctx, req.(*GetCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetStorageSlot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStorageSlotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetStorageSlot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetStorageSlot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetStorageSlot(ctx, req.(*GetStorageSlotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_Subscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_Unsubscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_EstimateGas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateGasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).EstimateGas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_EstimateGas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).EstimateGas(ctx, req.(*EstimateGasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetLogs(ctx, req.(*GetLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).HealthCheck(ctx, req.(*EmptyArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetBatch(ctx, req.(*GetBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetBatchBySeqNo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBatchBySeqNoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetBatchBySeqNo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetBatchBySeqNo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetBatchBySeqNo(ctx, req.(*GetBatchBySeqNoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetRollupData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRollupDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetRollupData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetRollupData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetRollupData(ctx, req.(*GetRollupDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_CreateBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).CreateBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_CreateBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).CreateBatch(ctx, req.(*CreateBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_CreateRollup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRollupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).CreateRollup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_CreateRollup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).CreateRollup(ctx, req.(*CreateRollupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_ExportCrossChainData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportCrossChainDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).ExportCrossChainData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_ExportCrossChainData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).ExportCrossChainData(ctx, req.(*ExportCrossChainDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_DebugTraceTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebugTraceTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).DebugTraceTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_DebugTraceTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).DebugTraceTransaction(ctx, req.(*DebugTraceTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_StreamL2Updates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamL2UpdatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EnclaveProtoServer).StreamL2Updates(m, &grpc.GenericServerStream[StreamL2UpdatesRequest, EncodedUpdateResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EnclaveProto_StreamL2UpdatesServer = grpc.ServerStreamingServer[EncodedUpdateResponse]

func _EnclaveProto_DebugEventLogRelevancy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebugEventLogRelevancyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).DebugEventLogRelevancy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_DebugEventLogRelevancy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).DebugEventLogRelevancy(ctx, req.(*DebugEventLogRelevancyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetTotalContractCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTotalContractCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetTotalContractCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetTotalContractCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetTotalContractCount(ctx, req.(*GetTotalContractCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetReceiptsByAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReceiptsByAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetReceiptsByAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetReceiptsByAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetReceiptsByAddress(ctx, req.(*GetReceiptsByAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_EnclavePublicConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnclavePublicConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).EnclavePublicConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_EnclavePublicConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).EnclavePublicConfig(ctx, req.(*EnclavePublicConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EnclaveProto_ServiceDesc is the grpc.ServiceDesc for EnclaveProto service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnclaveProto_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "generated.EnclaveProto",
	HandlerType: (*EnclaveProtoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _EnclaveProto_Status_Handler,
		},
		{
			MethodName: "Attestation",
			Handler:    _EnclaveProto_Attestation_Handler,
		},
		{
			MethodName: "GenerateSecret",
			Handler:    _EnclaveProto_GenerateSecret_Handler,
		},
		{
			MethodName: "InitEnclave",
			Handler:    _EnclaveProto_InitEnclave_Handler,
		},
		{
			MethodName: "EnclaveID",
			Handler:    _EnclaveProto_EnclaveID_Handler,
		},
		{
			MethodName: "SubmitL1Block",
			Handler:    _EnclaveProto_SubmitL1Block_Handler,
		},
		{
			MethodName: "SubmitTx",
			Handler:    _EnclaveProto_SubmitTx_Handler,
		},
		{
			MethodName: "SubmitBatch",
			Handler:    _EnclaveProto_SubmitBatch_Handler,
		},
		{
			MethodName: "ObsCall",
			Handler:    _EnclaveProto_ObsCall_Handler,
		},
		{
			MethodName: "GetTransactionCount",
			Handler:    _EnclaveProto_GetTransactionCount_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _EnclaveProto_Stop_Handler,
		},
		{
			MethodName: "GetTransaction",
			Handler:    _EnclaveProto_GetTransaction_Handler,
		},
		{
			MethodName: "GetTransactionReceipt",
			Handler:    _EnclaveProto_GetTransactionReceipt_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _EnclaveProto_GetBalance_Handler,
		},
		{
			MethodName: "GetCode",
			Handler:    _EnclaveProto_GetCode_Handler,
		},
		{
			MethodName: "GetStorageSlot",
			Handler:    _EnclaveProto_GetStorageSlot_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _EnclaveProto_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _EnclaveProto_Unsubscribe_Handler,
		},
		{
			MethodName: "EstimateGas",
			Handler:    _EnclaveProto_EstimateGas_Handler,
		},
		{
			MethodName: "GetLogs",
			Handler:    _EnclaveProto_GetLogs_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _EnclaveProto_HealthCheck_Handler,
		},
		{
			MethodName: "GetBatch",
			Handler:    _EnclaveProto_GetBatch_Handler,
		},
		{
			MethodName: "GetBatchBySeqNo",
			Handler:    _EnclaveProto_GetBatchBySeqNo_Handler,
		},
		{
			MethodName: "GetRollupData",
			Handler:    _EnclaveProto_GetRollupData_Handler,
		},
		{
			MethodName: "CreateBatch",
			Handler:    _EnclaveProto_CreateBatch_Handler,
		},
		{
			MethodName: "CreateRollup",
			Handler:    _EnclaveProto_CreateRollup_Handler,
		},
		{
			MethodName: "ExportCrossChainData",
			Handler:    _EnclaveProto_ExportCrossChainData_Handler,
		},
		{
			MethodName: "DebugTraceTransaction",
			Handler:    _EnclaveProto_DebugTraceTransaction_Handler,
		},
		{
			MethodName: "DebugEventLogRelevancy",
			Handler:    _EnclaveProto_DebugEventLogRelevancy_Handler,
		},
		{
			MethodName: "GetTotalContractCount",
			Handler:    _EnclaveProto_GetTotalContractCount_Handler,
		},
		{
			MethodName: "GetReceiptsByAddress",
			Handler:    _EnclaveProto_GetReceiptsByAddress_Handler,
		},
		{
			MethodName: "EnclavePublicConfig",
			Handler:    _EnclaveProto_EnclavePublicConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamL2Updates",
			Handler:       _EnclaveProto_StreamL2Updates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "enclave.proto",
}
