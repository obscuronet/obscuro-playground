# Obscuro Upgrades

This design covers the operational aspects of upgrading Obscuro.
The mechanism by which an upgrade is validated is covered in the "Upgrading_on_pos.md" document.

We'll start by identifying the types of scenarios that will require a software upgrade, and next, we'll propose the 
procedures and the technical changes required to achieve them. 

Note: This document is written with the single aggregator model, but it should apply equally to the decentralised POBI.

## Prerequisites

Upgradeability is a very complex topic. We'll start by listing the concerns specific to Obscuro and by creating 
some classifications.

### Obscuro secrets

There are two main secrets on an Obscuro node :

1. The master seed, aka "the shared secret", is the basis of all communication between enclaves, users and enclaves, and data availability on Ethereum.
2. The key for connecting to the local database, which lives in its own enclave. 
   - Note: Obscuro uses EdgelessDB, a modified MySQL running inside an enclave. The connection to the database is made using a key generated during the setup phase of the enclave. The EdgelessDB enclave ensures that only the owner of that key can read data.

Access to these secrets will allow attackers to read private user data.
Both secrets are sealed locally with a key derived from the current measurement of the enclave.


### Random notes

- The privacy of the ledger data is guaranteed by the security of the local secrets.
- The main reason for a "privacy" upgrade is the discovery of a vulnerability that can leak data.
- Most upgrades will hopefully be for mundane reasons such as improvements. 
- Obscuro is an L2 with a governance mechanism that takes place on the Ethereum Management Contract (MC). The decisions made by 
the governance contract must be understood and enforced by the enclave. See more details in the "Upgrading_on_pos.md" document. 


## Upgrade reasons for Obscuro

1. To fix security bugs which can impact the integrity of the ledger.  
1. To fix security bugs that can impact the ledger's privacy.  
1. To fix non-security (usability) bugs or to improve performance.
1. To add features.
1. To fix or to improve the protocol.
1. Microcode upgrades for SGX vulnerabilities that can be fixed with a firmware upgrade.
1. CPU hardware upgrades in case the SGX vulnerability can't be fixed with software.


## Rolling out an upgrade

There are two types of upgrades in any decentralised network when considering how they can be rolled out. 
In this section, we'll analyse how privacy-specific concerns fit into this classification.

### 1. Consensus upgrades

When there is a change to the format of transactions, to the data model, to opcodes or to the actual consensus protocol 
it means that a non-upgraded node that doesn't know about that change will not be able to function when it receives
data created by an upgraded node.

These types of changes can be further classified based on how the upgrade is intended to be rolled out. 

####  a. "Hard" forks

This is the typical consensus upgrade where non-upgraded nodes will no longer be able to understand the new rules, 
so won't be able to participate any more.
Rolling such a change to the node operators requires coordination because everyone needs to be ready when the new rules
are activated.

In Ethereum, such upgrades are triggered at a certain "block height". The node software will contain the logic for both the old
version and the new version, and when the block height is reached, it will start applying the new rules.
This trick means that there is a window during which the operators can upgrade to the new version on their own time. 
If they don't, then they will be left out. 

Note: Sometimes, there are node operators who don't agree with a certain upgrade and continue using the old software, 
which results in an actual "fork". For example, "Ethereum Classic" after the DAO hack or the "Ethereum Proof of work" after the merge.

####  b. "Soft" forks

There is another "trick" that developers have when they want to roll out upgrades in a gradual non-invasive fashion.
They can implement the change such that the previous version does not crash when encountering data generated by the new version, for example, by assigning a new implicit meaning to an existing field.

There are multiple issues with this option. It was used mostly in the early days, but currently, the "hard fork" approach 
with a block number activation date is the preferred option.  

In Obscuro, we'll use the preferred Ethereum approach.


### 2. Local only upgrades

These are upgrades that only impact the node operator. 
Like better metrics, improved RPC endpoints, better performance, etc. 
This version can be installed by a node operator at any time and is entirely optional.


### 3. Privacy related upgrades

This is a type of upgrade that is specific to Obscuro (or other privacy networks).
For example, necessary to remove a side channel or another avenue where data can be leaked.

This is not a "consensus upgrade" in the traditional sense, but it has to be treated equally because if there is a single
node operator with a vulnerable version on the network, then privacy is considered compromised.
Also, there is no incentive for users to perform this upgrade, so it has to be enforced similarly to a consensus upgrade.

After the rollout of such an upgrade, it is mandatory to change the secrets.

Upgrading the SGX firmware or completely changing hardware falls under the same category.


## Obscuro architecture 

In this section, we'll look at the architecture and analyse how upgrading different components fits into the above categories.

![architecture diagram](./obscuro_arch.jpeg)

### Trusted Computing Base (Enclave, Database and SGX) 

Any change to this codebase will have to go through the attestation whitelisting process.

Note that not all changes must be treated as a consensus upgrade. 
It is possible to make a pure performance improvement change which is optional.

Allowing multiple approved versions in the period between two blocks will require some extra logic.

Note: It is critical to design an upgrading mechanism in phase 1.

### Host

Changes to the host component will most likely be for usability and performance reasons.
Some upgrades could be consensus upgrades as well, for example, on a change of protocol.

Note: Not critical for an upgrading mechanism to be present in phase 1.

### The Wallet extension

This is the component installed by end users which communicates with Obscuro nodes via RPC.
For a good UX, Obscuro nodes must be backwards compatible and support even older versions of the Wallet extension.
There must be warnings and mechanisms to help users upgrade to the latest version.

Note: Not critical for an upgrading mechanism to be present in phase 1.

## Attestation whitelisting

The management contract will not support direct attestation verification, which means it has to whitelist a genesis enclave, 
by relying on incentivising users and researchers to make sure that the attestation is the right code running on secure hardware.

The genesis enclave for each new version must be published and whitelisted by the contract, together with a link to the source
code that produces that binary image.

This is the format of the event produced by the Management contract when the lifecycle is finalised.

```
 UpgradeEvent(
   - WhitelistedGenesisAttestation // a node installed with the new version
   - EnforcedHeight                // the rollup height from which only the new version will move forward. It can be -1 if not applicable.
   - RotateMasterSeed              // boolean indicating whether 
   - Attributes                    // a map of attributes that will be understood by the current version of the enclave.  
   )
```

Note: In phase 1, the event can be emitted when the administrator of the contract calls an "approveVersion" function.
This will give the upgrading power to the administrator, but in a transparent way.


## Minimum viable upgrade mechanism

This section describes the minimum implementation required in phase 1.

Unlike most software that can get away with not thinking about upgrading during early development, TEE software doesn't have
this luxury.
Without a mechanism put in place in the initial release, the enclave cannot be upgraded at all because any other version will
not be able to read the data.

This is only a concern for the Obscuro enclave, as the upgrading of the Host component can be designed afterwards.

### High-level tasks

#### Management contract

- Create the UpgradeEvent.
- Add a function to publish metadata about a release.
- Add a function callable only by the admin to approve one of the published releases.

#### Enclave 

1. Implement the UpgradeEvent authentication mechanism.
   - Logic to understand the beacon chain canonical chain
   - Minimal heuristics to mitigate "Weak subjectivity."

2. Implement logic to verify an attestation against the approved version.

3. Create an RPC endpoint to hand over secrets to an approved version, encrypted with the key.

4. Logic to stop operating at the block height specified in the UpgradeEvent.


#### Host level
Doesn't require any special functionality in phase 1.


### Process

1. The whitelisting of the enclave is performed on the MC, and Upgrade Event (UE) is emitted.
2. During normal operation, the current version of the Enclave (CE) will consume and authenticate the UE.
3. The operator will call the RPC endpoint, which will hand over secrets encrypted with the key of the New Enclave(NE).
4. The NE will start up and will run in the backwards compatibility mode until the block number mentioned in the UE is reached.
5. The CE will continue operating until the block height in the UE is reached when it will exit. By now, it will assume that the NE has taken over.

#### The Sequencer

The sequencer will undergo the same process.
The CE will continue to produce batches/rollups until the specified block.

All the other nodes will use the UpgradeEvents to identify the sequencer between any two block heights. 


#### The Genesis Upgrade Event

The "UpgradeEvent" mechanism can be used for the genesis as well.


## Phase 2 

In this section, we'll analyse what an actual upgrade will look like from v1 to v2 and from v2 to v3.
And some thoughts about how to handle 


